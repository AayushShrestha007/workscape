{"ast":null,"code":"import * as r from \"restructure\";\nimport { readUInt8, readUInt16BE, readUInt16LE, readUInt32BE, readUInt32LE, uint8ArrayToHexString, uint8ArrayToString } from \"./utils.js\";\nconst tags = {\n  ifd: {\n    \"010e\": \"imageDescription\",\n    \"010f\": \"make\",\n    \"011a\": \"xResolution\",\n    \"011b\": \"yResolution\",\n    \"011c\": \"planarConfiguration\",\n    \"012d\": \"transferFunction\",\n    \"013b\": \"artist\",\n    \"013e\": \"whitePoint\",\n    \"013f\": \"primaryChromaticities\",\n    \"0100\": \"imageWidth\",\n    \"0101\": \"imageHeight\",\n    \"0102\": \"bitsPerSample\",\n    \"0103\": \"compression\",\n    \"0106\": \"photometricInterpretation\",\n    \"0110\": \"model\",\n    \"0111\": \"stripOffsets\",\n    \"0112\": \"orientation\",\n    \"0115\": \"samplesPerPixel\",\n    \"0116\": \"rowsPerStrip\",\n    \"0117\": \"stripByteCounts\",\n    \"0128\": \"resolutionUnit\",\n    \"0131\": \"software\",\n    \"0132\": \"dateTime\",\n    \"0201\": \"jpegInterchangeFormat\",\n    \"0202\": \"jpegInterchangeFormatLength\",\n    \"0211\": \"ycbCrCoefficients\",\n    \"0212\": \"ycbCrSubSampling\",\n    \"0213\": \"ycbCrPositioning\",\n    \"0214\": \"referenceBlackWhite\",\n    \"829a\": \"exposureTime\",\n    \"829d\": \"fNumber\",\n    \"920a\": \"focalLength\",\n    \"927c\": \"makerNote\",\n    8298: \"copyright\",\n    8769: \"exifIFDPointer\",\n    8822: \"exposureProgram\",\n    8824: \"spectralSensitivity\",\n    8825: \"gpsInfoIFDPointer\",\n    8827: \"photographicSensitivity\",\n    8828: \"oecf\",\n    8830: \"sensitivityType\",\n    8831: \"standardOutputSensitivity\",\n    8832: \"recommendedExposureIndex\",\n    8833: \"isoSpeed\",\n    8834: \"isoSpeedLatitudeyyy\",\n    8835: \"isoSpeedLatitudezzz\",\n    9000: \"exifVersion\",\n    9003: \"dateTimeOriginal\",\n    9004: \"dateTimeDigitized\",\n    9101: \"componentsConfiguration\",\n    9102: \"compressedBitsPerPixel\",\n    9201: \"shutterSpeedValue\",\n    9202: \"apertureValue\",\n    9203: \"brightnessValue\",\n    9204: \"exposureBiasValue\",\n    9205: \"maxApertureValue\",\n    9206: \"subjectDistance\",\n    9207: \"meteringMode\",\n    9208: \"lightSource\",\n    9209: \"flash\",\n    9214: \"subjectArea\",\n    9286: \"userComment\",\n    9290: \"subSecTime\",\n    9291: \"subSecTimeOriginal\",\n    9292: \"subSecTimeDigitized\",\n    a000: \"flashpixVersion\",\n    a001: \"colorSpace\",\n    a002: \"pixelXDimension\",\n    a003: \"pixelYDimension\",\n    a004: \"relatedSoundFile\",\n    a005: \"interoperabilityIFDPointer\",\n    a20b: \"flashEnergy\",\n    a20c: \"spatialFrequencyResponse\",\n    a20e: \"focalPlaneXResolution\",\n    a20f: \"focalPlaneYResolution\",\n    a40a: \"sharpness\",\n    a40b: \"deviceSettingDescription\",\n    a40c: \"subjectDistanceRange\",\n    a210: \"focalPlaneResolutionUnit\",\n    a214: \"subjectLocation\",\n    a215: \"exposureIndex\",\n    a217: \"sensingMethod\",\n    a300: \"fileSource\",\n    a301: \"sceneType\",\n    a302: \"cfaPattern\",\n    a401: \"customRendered\",\n    a402: \"exposureMode\",\n    a403: \"whiteBalance\",\n    a404: \"digitalZoomRatio\",\n    a405: \"focalLengthIn35mmFilm\",\n    a406: \"sceneCaptureType\",\n    a407: \"gainControl\",\n    a408: \"contrast\",\n    a409: \"saturation\",\n    a420: \"imageUniqueID\",\n    a430: \"cameraOwnerName\",\n    a431: \"bodySerialNumber\",\n    a432: \"lensSpecification\",\n    a433: \"lensMake\",\n    a434: \"lensModel\",\n    a435: \"lensSerialNumber\",\n    a500: \"gamma\"\n  },\n  gps: {\n    \"0000\": \"gpsVersionID\",\n    \"0001\": \"gpsLatitudeRef\",\n    \"0002\": \"gpsLatitude\",\n    \"0003\": \"gpsLongitudeRef\",\n    \"0004\": \"gpsLongitude\",\n    \"0005\": \"gpsAltitudeRef\",\n    \"0006\": \"gpsAltitude\",\n    \"0007\": \"gpsTimeStamp\",\n    \"0008\": \"gpsSatellites\",\n    \"0009\": \"gpsStatus\",\n    \"000a\": \"gpsMeasureMode\",\n    \"000b\": \"gpsDOP\",\n    \"000c\": \"gpsSpeedRef\",\n    \"000d\": \"gpsSpeed\",\n    \"000e\": \"gpsTrackRef\",\n    \"000f\": \"gpsTrack\",\n    \"0010\": \"gpsImgDirectionRef\",\n    \"0011\": \"gpsImgDirection\",\n    \"0012\": \"gpsMapDatum\",\n    \"0013\": \"gpsDestLatitudeRef\",\n    \"0014\": \"gpsDestLatitude\",\n    \"0015\": \"gpsDestLongitudeRef\",\n    \"0016\": \"gpsDestLongitude\",\n    \"0017\": \"gpsDestBearingRef\",\n    \"0018\": \"gpsDestBearing\",\n    \"0019\": \"gpsDestDistanceRef\",\n    \"001a\": \"gpsDestDistance\",\n    \"001b\": \"gpsProcessingMethod\",\n    \"001c\": \"gpsAreaInformation\",\n    \"001d\": \"gpsDateStamp\",\n    \"001e\": \"gpsDifferential\",\n    \"001f\": \"gpsHPositioningError\"\n  }\n};\nclass IDFEntries {\n  constructor(bigEndian) {\n    this.bigEndian = bigEndian;\n    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\n  }\n  _getTagValue(dataValue, dataFormat) {\n    const uint16 = pos => this.bigEndian ? readUInt16BE(dataValue, pos) : readUInt16LE(dataValue, pos);\n    const uint32 = pos => this.bigEndian ? readUInt32BE(dataValue, pos) : readUInt32LE(dataValue, pos);\n    switch (dataFormat) {\n      case 1:\n        return readUInt8(dataValue, 0);\n      case 2:\n        return dataValue.toString(\"ascii\").replace(/\\0+$/, \"\");\n      case 3:\n        return uint16(0);\n      case 4:\n        return uint32(0);\n      case 5:\n        const tagValue = [];\n        for (var i = 0; i < dataValue.length; i += 8) {\n          tagValue.push(uint32(i) / uint32(i + 4));\n        }\n        return tagValue;\n      case 7:\n        return null;\n      case 10:\n        {\n          return uint32(0) / uint32(4);\n        }\n      default:\n        return \"0x\" + dataValue.toString(\"hex\");\n    }\n  }\n  _decodeIDFEntries(buffer, tags, offset) {\n    let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let pos = 2;\n    const entries = {};\n    const uint16 = pos => this.bigEndian ? readUInt16BE(buffer, pos) : readUInt16LE(buffer, pos);\n    const uint32 = pos => this.bigEndian ? readUInt32BE(buffer, pos) : readUInt32LE(buffer, pos);\n    const numberOfEntries = uint16(0);\n    for (let i = 0; i < numberOfEntries; i++) {\n      const tagAddress = buffer.slice(pos, pos + 2);\n      const dataFormat = uint16(pos + 2);\n      const componentsNumber = uint32(pos + 4);\n      const componentsBytes = this.bytes[dataFormat];\n      const dataLength = componentsNumber * componentsBytes;\n      let dataValue = buffer.slice(pos + 8, pos + 12);\n      if (dataLength > 4) {\n        const valueOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);\n        const dataOffset = valueOffset - offset;\n        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n      }\n      const tagValue = this._getTagValue(dataValue, dataFormat);\n      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());\n      const tagName = tags[tagNumber];\n      entries[tagName] = tagValue;\n      pos += 12;\n    }\n    return entries;\n  }\n  decode(stream, parent) {\n    let buffer = stream.buffer.slice(stream.pos);\n    const offsetToFirstIFD = parent.offsetToFirstIFD;\n    if (offsetToFirstIFD > buffer.length) {\n      stream.pos += parent.parent.length - 16;\n      return {};\n    }\n    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);\n    const {\n      exifIFDPointer,\n      gpsInfoIFDPointer\n    } = entries;\n    if (exifIFDPointer) {\n      buffer = buffer.slice(exifIFDPointer - offsetToFirstIFD);\n      entries.subExif = this._decodeIDFEntries(buffer, tags.ifd, exifIFDPointer);\n    }\n    if (gpsInfoIFDPointer) {\n      const gps = gpsInfoIFDPointer;\n      buffer = buffer.slice(exifIFDPointer ? gps - exifIFDPointer : gps - offsetToFirstIFD);\n      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);\n    }\n    stream.pos += parent.parent.length - 16;\n    return entries;\n  }\n}\nconst IFDData = bigEndian => {\n  const uint16 = bigEndian ? r.uint16be : r.uint16le;\n  const uint32 = bigEndian ? r.uint32be : r.uint32le;\n  return new r.Struct({\n    fortyTwo: uint16,\n    offsetToFirstIFD: uint32,\n    entries: new IDFEntries(bigEndian)\n  });\n};\nclass TIFFHeader {\n  decode(stream, parent) {\n    const byteOrder = uint8ArrayToString(stream.buffer.slice(stream.pos, stream.pos + 2));\n    const bigEndian = byteOrder === \"MM\";\n    stream.pos += 2;\n    const data = IFDData(bigEndian).decode(stream, parent);\n    return data.entries;\n  }\n}\nconst EXIFMarker = {\n  name: () => \"EXIF\",\n  length: r.uint16be,\n  identifier: new r.String(6),\n  entries: new TIFFHeader()\n};\nexport default EXIFMarker;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}