{"ast":null,"code":"import * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport class Pointer extends Base {\n  constructor(offsetType, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') {\n      this.type = null;\n    }\n    if (this.options.type == null) {\n      this.options.type = 'local';\n    }\n    if (this.options.allowNull == null) {\n      this.options.allowNull = true;\n    }\n    if (this.options.nullValue == null) {\n      this.options.nullValue = 0;\n    }\n    if (this.options.lazy == null) {\n      this.options.lazy = false;\n    }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if (offset === this.options.nullValue && this.options.allowNull) {\n      return null;\n    }\n    let relative;\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx._startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos - this.offsetType.size();\n        break;\n      case 'parent':\n        relative = ctx.parent._startOffset;\n        break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n        relative = c._startOffset || 0;\n    }\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n    const ptr = offset + relative;\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) {\n          return val;\n        }\n        const {\n          pos\n        } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue\n        });\n      }\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local':\n      case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default:\n        // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n    let {\n      type\n    } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n    return this.offsetType.size();\n  }\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if (val == null) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default:\n        // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n    let {\n      type\n    } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}