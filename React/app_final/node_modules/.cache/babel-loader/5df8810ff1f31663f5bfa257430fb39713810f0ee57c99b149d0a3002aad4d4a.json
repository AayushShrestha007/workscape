{"ast":null,"code":"import { Struct } from './Struct.js';\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\nexport class VersionedStruct extends Struct {\n  constructor(type) {\n    let versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n  decode(stream, parent) {\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const res = this._setup(stream, parent, length);\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n    const fields = this.versions[res.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n    this._parseFields(stream, res, fields);\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n  size(val, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n    return size;\n  }\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}