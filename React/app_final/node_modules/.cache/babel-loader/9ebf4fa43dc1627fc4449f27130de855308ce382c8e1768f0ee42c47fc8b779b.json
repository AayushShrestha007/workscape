{"ast":null,"code":"import { Base } from './Base.js';\nimport { Number as NumberT } from './Number.js';\nimport * as utils from './utils.js';\nclass ArrayT extends Base {\n  constructor(type, length) {\n    let lengthType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'count';\n    super();\n    this.type = type;\n    this.length = length;\n    this.lengthType = lengthType;\n  }\n  decode(stream, parent) {\n    let length;\n    const {\n      pos\n    } = stream;\n    const res = [];\n    let ctx = parent;\n    if (this.length != null) {\n      length = utils.resolveLength(this.length, stream, parent);\n    }\n    if (this.length instanceof NumberT) {\n      // define hidden properties\n      Object.defineProperties(res, {\n        parent: {\n          value: parent\n        },\n        _startOffset: {\n          value: pos\n        },\n        _currentOffset: {\n          value: 0,\n          writable: true\n        },\n        _length: {\n          value: length\n        }\n      });\n      ctx = res;\n    }\n    if (length == null || this.lengthType === 'bytes') {\n      const target = length != null ? stream.pos + length : (parent != null ? parent._length : undefined) ? parent._startOffset + parent._length : stream.length;\n      while (stream.pos < target) {\n        res.push(this.type.decode(stream, ctx));\n      }\n    } else {\n      for (let i = 0, end = length; i < end; i++) {\n        res.push(this.type.decode(stream, ctx));\n      }\n    }\n    return res;\n  }\n  size(array, ctx) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!array) {\n      return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);\n    }\n    let size = 0;\n    if (this.length instanceof NumberT) {\n      size += this.length.size();\n      ctx = {\n        parent: ctx,\n        pointerSize: 0\n      };\n    }\n    for (let item of array) {\n      size += this.type.size(item, ctx);\n    }\n    if (ctx && includePointers && this.length instanceof NumberT) {\n      size += ctx.pointerSize;\n    }\n    return size;\n  }\n  encode(stream, array, parent) {\n    let ctx = parent;\n    if (this.length instanceof NumberT) {\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent\n      };\n      ctx.pointerOffset = stream.pos + this.size(array, ctx, false);\n      this.length.encode(stream, array.length);\n    }\n    for (let item of array) {\n      this.type.encode(stream, item, ctx);\n    }\n    if (this.length instanceof NumberT) {\n      let i = 0;\n      while (i < ctx.pointers.length) {\n        const ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }\n}\nexport { ArrayT as Array };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}