{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2024 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  function createTextReader(setup) {\n    var char1 = \"\";\n    var char2 = \"\";\n    var i = 0;\n    var verifier = setup();\n    return function (text) {\n      while (i < text.length) {\n        char1 = text.charAt(i++);\n        char2 = text.charAt(i);\n        var verified = verifier(char1, char2);\n        if (verified !== void 0) {\n          return verified;\n        }\n      }\n    };\n  }\n  var isNotLetter = RegExp.prototype.test.bind(/\\s|(?![\\'])[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/);\n  function createHTMLVerifier() {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (chars[0] === \">\") {\n          accumulate();\n          skip = false;\n        }\n      } else if (chars[0] === \"<\" && (!isNotLetter(chars[1]) || chars[1] === \"/\")) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenCharVerifier(hyphenChar) {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {\n          accumulate();\n          skip = false;\n        }\n      } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenationVerifier(verifiers, minWordLength) {\n    return function () {\n      var accum0 = \"\";\n      var accum = \"\";\n      function accumulate() {\n        accum0 += accum;\n        accum = \"\";\n      }\n      function resolveWith(value) {\n        accum0 = \"\";\n        accum = \"\";\n        return value;\n      }\n      return function (char1, char2) {\n        accum += char1;\n        var skip = verifiers.reduce(function (skip2, verify) {\n          return skip2 || verify(accumulate, [char1, char2]);\n        }, false);\n        if (!skip) {\n          if (isNotLetter(char1) && !isNotLetter(char2)) {\n            accumulate();\n          }\n          if (!isNotLetter(char1) && isNotLetter(char2)) {\n            if (accum.length >= minWordLength) {\n              return resolveWith([accum0, accum]);\n            } else {\n              accumulate();\n            }\n          }\n        }\n        if (char2 === \"\") {\n          if (accum.length < minWordLength || skip) {\n            accumulate();\n          }\n          return resolveWith([accum0, accum]);\n        }\n      };\n    };\n  }\n  function createCharIterator(str) {\n    var i = 0;\n    function nextChar() {\n      return str[i++];\n    }\n    function isLastLetter() {\n      return str.length === i + 1;\n    }\n    return [nextChar, isLastLetter];\n  }\n  function createStringSlicer(str) {\n    var i = 0,\n      slice = str;\n    function next() {\n      slice = str.slice(i++);\n      if (slice.length < 3) {\n        return;\n      }\n      return slice;\n    }\n    function isFirstCharacter() {\n      return i === 2;\n    }\n    return [next, isFirstCharacter];\n  }\n  function hyphenateWord(text, levelsTable, patternTree, debug, hyphenChar) {\n    var levels = new Array(text.length + 1),\n      loweredText = (\".\" + text.toLocaleLowerCase() + \".\").split(\"\"),\n      wordSlice,\n      letter,\n      treePtr,\n      nextPtr,\n      patternLevelsIndex,\n      patternLevels,\n      patternEntityIndex = -1,\n      slicer,\n      nextSlice,\n      isFirstCharacter,\n      charIterator,\n      nextLetter,\n      isLastLetter;\n    for (var i = levels.length; i--;) levels[i] = 0;\n    slicer = createStringSlicer(loweredText);\n    nextSlice = slicer[0];\n    isFirstCharacter = slicer[1];\n    while (wordSlice = nextSlice()) {\n      patternEntityIndex++;\n      if (isFirstCharacter()) {\n        patternEntityIndex--;\n      }\n      treePtr = patternTree;\n      charIterator = createCharIterator(wordSlice);\n      nextLetter = charIterator[0];\n      isLastLetter = charIterator[1];\n      while (letter = nextLetter()) {\n        if (treePtr[letter] === void 0) {\n          break;\n        }\n        nextPtr = treePtr[letter];\n        treePtr = nextPtr[0];\n        patternLevelsIndex = nextPtr[1];\n        if (treePtr === void 0) {\n          treePtr = {};\n          patternLevelsIndex = nextPtr;\n        }\n        if (isLastLetter()) {\n          continue;\n        }\n        if (patternLevelsIndex === void 0) {\n          continue;\n        }\n        if (!levelsTable[patternLevelsIndex].splice) {\n          levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice(\"\");\n        }\n        patternLevels = levelsTable[patternLevelsIndex];\n        for (var k = 0; k < patternLevels.length; k++) levels[patternEntityIndex + k] = Math.max(patternLevels[k], levels[patternEntityIndex + k]);\n      }\n    }\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var hyphenatedText = \"\";\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n    }\n    return hyphenatedText;\n  }\n  function start(text, levelsTable, patterns, cache, debug, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      resolveNewText(newText);\n    }\n    var newText = \"\",\n      fragments,\n      readText = createTextReader(createHyphenationVerifier((skipHTML ? [createHTMLVerifier()] : []).concat(createHyphenCharVerifier(hyphenChar)), minWordLength)),\n      resolveNewText = function () {};\n    function nextTick() {\n      var loopStart = /* @__PURE__ */new Date();\n      while ((!isAsync || /* @__PURE__ */new Date() - loopStart < 10) && (fragments = readText(text))) {\n        if (fragments[1]) {\n          var cacheKey = fragments[1].length ? \"~\" + fragments[1] : \"\";\n          if (cache[cacheKey] === void 0) {\n            cache[cacheKey] = hyphenateWord(fragments[1], levelsTable, patterns, debug, hyphenChar);\n          }\n          fragments[1] = cache[cacheKey];\n        }\n        newText += fragments[0] + fragments[1];\n      }\n      if (!fragments) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n  var SETTING_DEFAULT_ASYNC = false;\n  var SETTING_DEFAULT_DEBUG = false;\n  var SETTING_DEFAULT_EXCEPTIONS = [];\n  var SETTING_DEFAULT_HTML = true;\n  var SETTING_DEFAULT_HYPH_CHAR = \"\\xAD\";\n  var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;\n  var SETTING_NAME_ASYNC = \"async\";\n  var SETTING_NAME_DEBUG = \"debug\";\n  var SETTING_NAME_EXCEPTIONS = \"exceptions\";\n  var SETTING_NAME_HTML = \"html\";\n  var SETTING_NAME_HYPH_CHAR = \"hyphenChar\";\n  var SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof self === \"object\" ? self : false ? void 0 : {};\n  function extend(target, source) {\n    target = target || {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function validateArray(value) {\n    return value instanceof Array;\n  }\n  function keyOrDefault(object, key, defaultValue, test) {\n    if (key in object && (test ? test(object[key]) : true)) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n  function exceptionsFromDefinition(excetionsList, hyphenChar) {\n    return excetionsList.reduce(function (exceptions, exception) {\n      exceptions[\"~\" + exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n      levelsTable = patternsDefinition[0].split(\",\"),\n      patterns = JSON.parse(patternsDefinition[1]),\n      minWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, SETTING_DEFAULT_MIN_WORD_LENGTH) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML),\n      userExceptions = keyOrDefault(options, SETTING_NAME_EXCEPTIONS, SETTING_DEFAULT_EXCEPTIONS, validateArray);\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = {};\n    if (patternsDefinition[2]) {\n      exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition[2], hyphenChar);\n    }\n    if (userExceptions && userExceptions.length) {\n      exceptions[cacheKey] = extend(exceptions[cacheKey], exceptionsFromDefinition(userExceptions, hyphenChar));\n    }\n    caches[cacheKey] = extend({}, exceptions[cacheKey]);\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n    return function (text, options2) {\n      options2 = options2 || {};\n      var localDebug = keyOrDefault(options2, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(options2, SETTING_NAME_HYPH_CHAR, hyphenChar),\n        localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0,\n        localUserExceptions = keyOrDefault(options2, SETTING_NAME_EXCEPTIONS, SETTING_DEFAULT_EXCEPTIONS, validateArray),\n        cacheKey2 = localHyphenChar + localMinWordLength;\n      if (!exceptions[cacheKey2] && patternsDefinition[2]) {\n        exceptions[cacheKey2] = exceptionsFromDefinition(patternsDefinition[2], localHyphenChar);\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      if (localUserExceptions && localUserExceptions.length) {\n        exceptions[cacheKey2] = extend(exceptions[cacheKey2], exceptionsFromDefinition(localUserExceptions, localHyphenChar));\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      return start(text, levelsTable, patterns, caches[cacheKey2], localDebug, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n  return createHyphenator;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}